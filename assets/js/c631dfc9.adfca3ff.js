"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6090],{7485:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"guides/json-pointer","title":"JSON Pointer","description":"JSON Pointer (RFC 6901) is a syntax for targeting a single value in JSON-like data. JSON Pointers can be resolved against data to retrieve the value, or used as part of a JSON Patch operation.","source":"@site/docs/guides/json-pointer.md","sourceDirName":"guides","slug":"/guides/json-pointer","permalink":"/json-p3/guides/json-pointer","draft":false,"unlisted":false,"editUrl":"https://github.com/jg-rp/json-p3/tree/docs/docs/guides/json-pointer.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"JSONPath Functions","permalink":"/json-p3/guides/jsonpath-functions"},"next":{"title":"JSON Patch","permalink":"/json-p3/guides/json-patch"}}');var t=o(4848),s=o(8453);const i={},a="JSON Pointer",l={},c=[{value:"Pointer resolution",id:"pointer-resolution",level:2},{value:"Errors and fallbacks",id:"errors-and-fallbacks",level:3},{value:"With parent",id:"with-parent",level:3},{value:"Utility methods",id:"utility-methods",level:2},{value:"<code>exists()</code>",id:"exists",level:3},{value:"<code>join()</code>",id:"join",level:3},{value:"<code>parent()</code>",id:"parent",level:3},{value:"<code>isRelativeTo()</code>",id:"isrelativeto",level:3},{value:"Relative JSON Pointer",id:"relative-json-pointer",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"json-pointer",children:"JSON Pointer"})}),"\n",(0,t.jsxs)(n.p,{children:["JSON Pointer (",(0,t.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc6901",children:"RFC 6901"}),") is a syntax for targeting a single value in JSON-like data. JSON Pointers can be ",(0,t.jsx)(n.em,{children:"resolved"})," against data to retrieve the value, or used as part of a JSON Patch operation."]}),"\n",(0,t.jsxs)(n.p,{children:["A JSON Pointer is a Unicode string containing slash (",(0,t.jsx)(n.code,{children:"/"}),") separated tokens. Each token is either a potential property name for a JSON object, or a potential index for a JSON array. When a property name contains a slash (",(0,t.jsx)(n.code,{children:"/"}),") or a tilde (",(0,t.jsx)(n.code,{children:"~"}),"), they are encoded as ",(0,t.jsx)(n.code,{children:"~1"})," and ",(0,t.jsx)(n.code,{children:"~0"}),", respectively."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["We have extended RFC 6901 to handle index/property pointers from ",(0,t.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/draft-hha-relative-json-pointer",children:"Relative JSON Pointer"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"pointer-resolution",children:"Pointer resolution"}),"\n",(0,t.jsxs)(n.p,{children:["Resolve a JSON Pointer against some data using ",(0,t.jsx)(n.a,{href:"../api/namespaces/jsonpointer/classes/JSONPointer#resolve",children:(0,t.jsx)(n.code,{children:"jsonpointer.resolve(pointer, data)"})}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { jsonpointer } from "json-p3";\n\nconst data = {\n  users: [\n    { name: "Sue", score: 100 },\n    { name: "John", score: 86 },\n    { name: "Sally", score: 84 },\n    { name: "Jane", score: 55 },\n  ],\n};\n\nconst rv = jsonpointer.resolve("/users/1", data);\nconsole.log(rv); // { name: \'John\', score: 86 }\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"resolve()"})," is a convenience function equivalent to ",(0,t.jsx)(n.code,{children:"new JSONPointer(pointer).resolve(data)"}),". Use the ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointer",children:(0,t.jsx)(n.code,{children:"JSONPointer"})})," constructor when you need to resolve the same pointer repeatedly against different data."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { JSONPointer } from "json-p3";\n\nconst someData = {\n  users: [\n    { name: "Sue", score: 100 },\n    { name: "John", score: 86 },\n    { name: "Sally", score: 84 },\n  ],\n};\n\nconst otherData = {\n  users: [{ name: "Brian" }, { name: "Roy" }],\n};\n\nconst pointer = new JSONPointer("/users/1");\nconsole.log(pointer.resolve(someData)); // { name: \'John\', score: 86 }\nconsole.log(pointer.resolve(otherData)); // { name: \'Roy\' }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"errors-and-fallbacks",children:"Errors and fallbacks"}),"\n",(0,t.jsxs)(n.p,{children:["If the pointer can't be resolved against the argument JSON value, one of ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointerIndexError",children:(0,t.jsx)(n.code,{children:"JSONPointerIndexError"})}),", ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointerKeyError",children:(0,t.jsx)(n.code,{children:"JSONPointerKeyError"})})," or ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointerTypeError",children:(0,t.jsx)(n.code,{children:"JSONPointerTypeError"})})," is thrown. All three exceptions inherit from ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointerResolutionError",children:(0,t.jsx)(n.code,{children:"JSONPointerResolutionError"})}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// .. continued from above\nconst rv = pointer.resolve("/users/1/age", data);\n// JSONPointerKeyError: no such property ("/users/1/age")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["A fallback value can be given as a third argument, which will be returned in the event of a ",(0,t.jsx)(n.code,{children:"JSONPointerResolutionError"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// .. continued from above\nconst rv = pointer.resolve("/users/1/age", data, -1);\nconsole.log(rv); // -1\n'})}),"\n",(0,t.jsx)(n.h3,{id:"with-parent",children:"With parent"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointer#resolvewithparent",children:(0,t.jsx)(n.code,{children:"resolveWithParent()"})})," is similar to ",(0,t.jsx)(n.code,{children:"resolve()"}),", but returns the target's parent value and the target value as a two-element array."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { JSONPointer } from "json-p3";\n\nconst data = {\n  users: [\n    { name: "Sue", score: 100 },\n    { name: "John", score: 86 },\n    { name: "Sally", score: 84 },\n  ],\n};\n\nconst pointer = new JSONPointer("/users/1");\nconst [parent, target] = pointer.resolveWithParent(data);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If the target value does not exist but the parent does, you'll get the parent object and the special ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/variables/UNDEFINED",children:(0,t.jsx)(n.code,{children:"UNDEFINED"})})," symbol. Similarly, if the pointer is pointing to the JSON document root, you'll get ",(0,t.jsx)(n.code,{children:"UNDEFINED"})," and the target document in its entirety."]}),"\n",(0,t.jsxs)(n.p,{children:["Otherwise, if the pointer's parent does not exist, a ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointerResolutionError",children:(0,t.jsx)(n.code,{children:"JSONPointerResolutionError"})})," is thrown."]}),"\n",(0,t.jsx)(n.h2,{id:"utility-methods",children:"Utility methods"}),"\n",(0,t.jsx)(n.h3,{id:"exists",children:(0,t.jsx)(n.code,{children:"exists()"})}),"\n",(0,t.jsxs)(n.p,{children:["Test for existence with ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointer#exists",children:(0,t.jsx)(n.code,{children:"JSONPointer.exists(data)"})}),". It returns ",(0,t.jsx)(n.code,{children:"true"})," if the target exists in ",(0,t.jsx)(n.em,{children:"data"}),", even if the target is falsy, and ",(0,t.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { JSONPointer } from "json-p3";\n\nconst data = { foo: { bar: [1, 2, 3] }, baz: false };\n\nlet pointer = new JSONPointer("/foo/bar/0");\nconsole.log(pointer.exists(data)); // true\n\npointer = new JSONPointer("/foo/bar/9");\nconsole.log(pointer.exists(data)); // false\n\npointer = new JSONPointer("/baz");\nconsole.log(pointer.exists(data)); // true\n'})}),"\n",(0,t.jsx)(n.h3,{id:"join",children:(0,t.jsx)(n.code,{children:"join()"})}),"\n",(0,t.jsxs)(n.p,{children:["Build child pointers using ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointer#join",children:(0,t.jsx)(n.code,{children:"JSONPointer.join(...tokens)"})}),". It takes any number of JSON Pointer tokens and returns a new ",(0,t.jsx)(n.code,{children:"JSONPointer"}),". Similar to joining a file system path, if a token has a leading slash, the previous pointer is ignored and a new ",(0,t.jsx)(n.code,{children:"JSONPointer"})," is created, before processing of remaining tokens continues."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { JSONPointer } from "json-p3";\n\nconst pointer = new JSONPointer("/foo/bar");\n\nconsole.log(pointer.toString()); // /foo/bar\nconsole.log(pointer.join("baz").toString()); // /foo/bar/baz\nconsole.log(pointer.join("baz", "0").toString()); // /foo/bar/baz/0\nconsole.log(pointer.join("baz/qux", "0").toString()); // /foo/bar/baz/qux/0\n'})}),"\n",(0,t.jsx)(n.h3,{id:"parent",children:(0,t.jsx)(n.code,{children:"parent()"})}),"\n",(0,t.jsxs)(n.p,{children:["Get a pointer to the parent of an existing JSON Pointer using ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointer#parent",children:(0,t.jsx)(n.code,{children:"JSONPointer.parent()"})}),". If the pointer is pointing to the document root, ",(0,t.jsx)(n.code,{children:"this"})," is returned."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { JSONPointer } from "json-p3";\n\nconst pointer = new JSONPointer("/foo/bar");\n\nconsole.log(pointer.toString()); // /foo/bar\nconsole.log(pointer.parent().toString()); // /foo\n'})}),"\n",(0,t.jsx)(n.h3,{id:"isrelativeto",children:(0,t.jsx)(n.code,{children:"isRelativeTo()"})}),"\n",(0,t.jsxs)(n.p,{children:["Test if a pointer is a child of another using ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointer#isrelativeto",children:(0,t.jsx)(n.code,{children:"JSONPointer.isRelativeTo()"})}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { JSONPointer } from "json-p3";\n\nconst pointer = new JSONPointer("/foo/bar");\n\nlet anotherPointer = new JSONPointer("/foo/bar/0");\nconsole.log(anotherPointer.isRelativeTo(pointer)); // true\n\nanotherPointer = new JSONPointer("/foo/baz");\nconsole.log(anotherPointer.isRelativeTo(pointer)); // false\n'})}),"\n",(0,t.jsx)(n.h2,{id:"relative-json-pointer",children:"Relative JSON Pointer"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/draft-hha-relative-json-pointer",children:"Relative JSON Pointer"})," syntax with ",(0,t.jsx)(n.a,{href:"/json-p3/api/namespaces/jsonpointer/classes/JSONPointer#to",children:(0,t.jsx)(n.code,{children:"JSONPointer.to(rel)"})})," to create a new pointer relative to an existing one."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { JSONPointer } from "json-p3";\n\nconst data = { foo: { bar: [1, 2, 3], baz: [4, 5, 6] } };\nconst pointer = new JSONPointer("/foo/bar/2");\n\nconsole.log(pointer.resolve(data)); // 3\nconsole.log(pointer.to("0-1").resolve(data)); // 2\nconsole.log(pointer.to("2/baz/2").resolve(data)); // 6\n'})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>a});var r=o(6540);const t={},s=r.createContext(t);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);